package com.droidmare.calendar.utils;

import android.content.res.Resources;
import android.util.Log;

import com.droidmare.R;
import com.droidmare.calendar.models.DateDataStructures;
import com.droidmare.calendar.models.EventListItem;

import java.time.DayOfWeek;
import java.util.ArrayList;
import java.util.Calendar;

//Utils for getting date information
//@author Eduardo on 08/02/2018.

public class DateUtils {

    private static Calendar calendar;

    private static Resources resources;

    private static String[] daysOfWeekLetter, daysOfWeekText, months;

    private static final int MIN_YEAR = 2000, MAX_YEAR = 2050;

    public static int currentDay, currentMonth, currentYear;

    public static String formattedDateText;

    //Fields for the date array generated by the method transformFromMillis:
    public static int MINUTE = 0;
    public static int HOUR = 1;
    public static int DAY = 2;
    public static int MONTH = 3;
    public static int YEAR = 4;

    public static void initDateParameters (Resources res){

        calendar = Calendar.getInstance();

        resources = res;

        DateDataStructures dateStructures = new DateDataStructures(res);

        DateUtils.daysOfWeekLetter = dateStructures.getDaysOfWeekLetter();
        DateUtils.daysOfWeekText = dateStructures.getDaysOfWeekText();
        DateUtils.months = dateStructures.getMonths();

        DateUtils.currentDay = calendar.get(Calendar.DAY_OF_MONTH);
        DateUtils.currentMonth = calendar.get(Calendar.MONTH);
        DateUtils.currentYear = calendar.get(Calendar.YEAR);
    }

    public static String getDayOfWeekLetter(int i) {
        return daysOfWeekLetter[i];
    }

    public static String getDayOfWeekText(int i) {
        return daysOfWeekText[i];
    }

    public static String getMonth (int i){
        return months[i];
    }

    public static int getMonthValue (String month) {
        for (int i = 0; i < months.length; i++)
            if (month.equals(months[i])) return i;
        return -1;
    }

    //This method will move back the attribute currentMonth to the previous month:
    public static void moveToPreviousMonth () {
        if (DateUtils.currentMonth != 0) DateUtils.currentMonth--;
        else {
            DateUtils.currentMonth = 11;

            moveToPreviousYear();
        }
    }

    //This method will move on the attribute currentMonth to the next month:
    public static void moveToNextMonth () {
        if (DateUtils.currentMonth != 11) DateUtils.currentMonth++;
        else {
            DateUtils.currentMonth = 0;

            moveToNextYear();
        }
    }

    //This method will move back the attribute currentYear to the previous year:
    public static void moveToPreviousYear () {
        if (DateUtils.currentYear != MIN_YEAR) DateUtils.currentYear--;

        else DateUtils.currentYear = MAX_YEAR;
    }

    //This method will move on the attribute currentYear to the next year:
    public static void moveToNextYear () {
        if (DateUtils.currentYear != MAX_YEAR) DateUtils.currentYear++;

        else DateUtils.currentYear = MIN_YEAR;
    }

    //This method will move back the given parameters to the previous month:
    public static int[] moveToPreviousMonth (Integer month, Integer year) {
        if (month != 0) month--;
        else {
            month = 11;

            year = moveToPreviousYear(year);
        }

        return new int[] {month, year};
    }

    //This method will move on the given parameters to the next month:
    public static int[] moveToNextMonth (Integer month, Integer year) {
        if (month != 11) month++;
        else {
            month = 0;

            year = moveToNextYear(year);
        }

        return new int[] {month, year};
    }

    //This method will move back the given parameter to the previous year:
    public static int moveToPreviousYear (Integer year) {
        if (year != MIN_YEAR) year--;

        else year = MAX_YEAR;

        return year;
    }

    //This method will move on the given parameter to the next year:
    public static int moveToNextYear (Integer year) {
        if (year != MAX_YEAR) year++;

        else year = MIN_YEAR;

        return year;
    }

    //This method returns the position of the current day inside a calendar grid:
    public static int getCurrentDayPosition() {

        return DateUtils.currentDay + DateUtils.findDayOfWeek() - 2;
    }

    //This method returns true if the attributes currentMonth and CurrentYear corresponds with the parameters:
    public static boolean sameMonthAndYear(int month, int year) {
        return (DateUtils.currentMonth == month && DateUtils.currentYear == year);
    }

    //This method returns true if the event's date is not the same as the DateUtils current date:
    public static boolean notSameDate(EventListItem event) {
        return (currentDay != event.getEventDay() || currentMonth != event.getEventMonth() || currentYear != event.getEventYear());
    }

    //This method returns true if the event's date is the same as the DateUtils current date:
    public static boolean sameDate(EventListItem event) {
        return (currentDay == event.getEventDay() && currentMonth == event.getEventMonth() && currentYear == event.getEventYear());
    }

    //This method returns whether or not the parameters are out of date:
    public static boolean outOfDate(int year, int month, int day, int hour, int minute) {

        calendar = Calendar.getInstance();

        boolean isOutDated = true;

        int currentMinute = calendar.get(Calendar.MINUTE);
        int currentHour = calendar.get(Calendar.HOUR_OF_DAY);
        int currentDay = calendar.get(Calendar.DAY_OF_MONTH);
        int currentMonth = calendar.get(Calendar.MONTH);
        int currentYear = calendar.get(Calendar.YEAR);

        if (year > currentYear)
            isOutDated = false;

        else if (year == currentYear && month > currentMonth)
            isOutDated = false;

        else if (year == currentYear && month == currentMonth && day > currentDay)
            isOutDated = false;

        else if (year == currentYear && month == currentMonth && day == currentDay && hour > currentHour)
            isOutDated = false;

        else if (year == currentYear && month == currentMonth && day == currentDay && hour == currentHour && minute >= currentMinute)
            isOutDated = false;

        return isOutDated;
    }

    //Method that returns whether or not the parameter dates are the same day:
    public static boolean isSameDay(long currentDate, long startDate) {
        return !isPrevious(currentDate, startDate) && !isPosterior(currentDate, startDate);
    }

    //Method that returns whether or not the currentDate parameter is previous to the startDate parameter:
    public static boolean isPrevious(long currentDate, long startDate) {
        int[] currentDateArray = DateUtils.transformFromMillis(currentDate);
        int[] startDateArray = DateUtils.transformFromMillis(startDate);

        return (currentDateArray[DateUtils.YEAR] < startDateArray[DateUtils.YEAR]
                || currentDateArray[DateUtils.YEAR] == startDateArray[DateUtils.YEAR] && currentDateArray[DateUtils.MONTH] < startDateArray[DateUtils.MONTH]
                || currentDateArray[DateUtils.YEAR] == startDateArray[DateUtils.YEAR] && currentDateArray[DateUtils.MONTH] == startDateArray[DateUtils.MONTH]
                && currentDateArray[DateUtils.DAY] < startDateArray[DateUtils.DAY]);
    }

    //Method that returns whether or not the currentDate parameter is posterior to the startDate parameter:
    private static boolean isPosterior(long currentDate, long startDate) {
        int[] currentDateArray = DateUtils.transformFromMillis(currentDate);
        int[] startDateArray = DateUtils.transformFromMillis(startDate);

        return (currentDateArray[DateUtils.YEAR] > startDateArray[DateUtils.YEAR]
                || currentDateArray[DateUtils.YEAR] == startDateArray[DateUtils.YEAR] && currentDateArray[DateUtils.MONTH] > startDateArray[DateUtils.MONTH]
                || currentDateArray[DateUtils.YEAR] == startDateArray[DateUtils.YEAR] && currentDateArray[DateUtils.MONTH] ==  startDateArray[DateUtils.MONTH]
                && currentDateArray[DateUtils.DAY] > startDateArray[DateUtils.DAY]);
    }

    //Method that returns the number of hours between the parameters startDate and currentDate (without DST differences):
    private static int getNumberOfHours (long startDate, long currentDate) {

        int numberOfHours = 0;

        //An array that contains the number of days for each month corresponding to the array's index (0 = january, 1 = february, etc):
        int[] monthsDays = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};

        Calendar startDateCalendar = Calendar.getInstance();
        startDateCalendar.setTimeInMillis(startDate);

        int startHour = startDateCalendar.get(Calendar.HOUR_OF_DAY);
        int startDay = startDateCalendar.get(Calendar.DAY_OF_MONTH);
        int startMonth = startDateCalendar.get(Calendar.MONTH);
        int startYear = startDateCalendar.get(Calendar.YEAR);

        Calendar currentDateCalendar = Calendar.getInstance();
        currentDateCalendar.setTimeInMillis(currentDate);

        int currentDay = currentDateCalendar.get(Calendar.DAY_OF_MONTH);
        int currentMonth = currentDateCalendar.get(Calendar.MONTH);
        int currentYear = currentDateCalendar.get(Calendar.YEAR);

        for (int year = startYear; year <= currentYear; year++) {

            //February's number of days must be calculated based on the current year:
            monthsDays[1] = numberOfDays(1, year);

            int month = 0;

            if (year == startYear) month = startMonth;

            for (; month < 12; month++) {

                if (startMonth == currentMonth && startYear == currentYear) {
                    if (startDay == currentDay) {
                        return numberOfHours;
                    }
                    else {
                        numberOfHours += 24 - startHour;
                        numberOfHours += 24 * (currentDay - startDay - 1);
                        return numberOfHours;
                    }
                }

                else if (month == startMonth && year == startYear) {
                    numberOfHours += 24 - startHour;
                    numberOfHours += 24 * (monthsDays[month] - startDay);
                }

                else if (month == currentMonth && year == currentYear) {
                    numberOfHours += 24 * (currentDay - 1);
                    return numberOfHours;
                }

                else numberOfHours += 24 * monthsDays[month];
            }
        }

        return (numberOfHours);
    }

    //Method that returns the number of days between the parameters startDate and currentDate (without DST differences):
    private static int getNumberOfDays (long startDate, long currentDate) {
        int numberOfHours = getNumberOfHours(startDate, currentDate);
        int numberOfDays = numberOfHours / 24;
        if (numberOfHours % 24 != 0) numberOfDays++;

        return numberOfDays;
    }

    public static long getNextDailyRepetition(long currentDate, long eventStartDate, long eventStopDate, int intervalTime) {

        long repetition;

        int[] eventDateArray = transformFromMillis(eventStartDate);
        int[] currentDateArray = transformFromMillis(currentDate);

        //When the event start date is posterior to the current date, the next event's repetition will be its start date:
        if (isPosterior(eventStartDate, currentDate)) {
            repetition = eventStartDate;
        }

        //When the event start date is previous to the actual current one:
        else if (isPrevious(eventStartDate, currentDate)) {
            repetition = getNextRepetitionByInterval(eventDateArray, currentDateArray, intervalTime);
        }

        //When the current day is equal to the actual current one:
        else {
            repetition = eventStartDate;

            if (currentDateArray[HOUR] > eventDateArray[HOUR] || currentDateArray[HOUR] == eventDateArray[HOUR] && currentDateArray[MINUTE] > eventDateArray[MINUTE]) {
                repetition = getMillisFromArray(eventDateArray);

                int[] repetitionArray;

                //After that, the interval is going to be added to the repetition date until the repetition is bigger than the current day or the event stop date:
                while (repetition < currentDate && (repetition < eventStopDate || eventStopDate == -1)) {
                    repetitionArray = getIncrementedDate(repetition, intervalTime);
                    repetition = getMillisFromArray(repetitionArray);
                }
            }
        }

        //In case of a repetition value bigger than the event stop date, the last repetition must be equal to the event start date, since that event is finished:
        if (repetition > eventStopDate && eventStopDate != -1) repetition = eventStartDate;

        return repetition;
    }

    private static long getNextRepetitionByInterval(int[] eventStartDate, int[] currentDate, int intervalTime){

        Calendar calendar = Calendar.getInstance();

        int monthNumberOfDays = calendar.getActualMaximum(Calendar.DAY_OF_MONTH);

        int currentMinute = currentDate[MINUTE];
        int currentHour = currentDate[HOUR];
        int currentDay = currentDate[DAY];
        int currentMonth = currentDate[MONTH];
        int currentYear = currentDate[YEAR];

        int eventMinute = eventStartDate[MINUTE];
        int eventHour = eventStartDate[HOUR];
        int eventDay = eventStartDate[DAY];
        int eventMonth = eventStartDate[MONTH];
        int eventYear = eventStartDate[YEAR];

        //The first thing that must be checked is the number of hours between the original reminder time and the current time so that the reminder hour can be
        //appropriately reset by working out the number of hours left until the next repetition if the alarm had been repeated since its original time and date:
        long reminderTime = getMillisFromArray(eventStartDate);
        long currentTime = DateUtils.getMillisFromArray(currentDate);

        //the method getNumberOfHours() returns the number of hours between the start date and the 00:00 of the current date, so in
        //order to obtain the actual number ofHours the current hour must be added to the result returned by the aforementioned method:
        long numberOfHours = getNumberOfHours(reminderTime, currentTime) + currentHour;
        long numberOfSkippedRep = numberOfHours / intervalTime;

        long hoursUntilNextRep;

        if (numberOfSkippedRep == 0) hoursUntilNextRep = intervalTime - numberOfHours;
        else hoursUntilNextRep = (intervalTime - (numberOfHours - numberOfSkippedRep * intervalTime)) % intervalTime;

        if (hoursUntilNextRep == 0 && currentMinute > eventMinute) hoursUntilNextRep = intervalTime;

        //Now it is necessary to modify the reminder attributes' values with the current time and date ones (if they are different from each other).
        //Given that the reminder could have been received out of its time and date (if the device was off for a long time, for instance):

        if (eventHour != currentHour) eventHour = currentHour;
        if (eventDay != currentDay) eventDay = currentDay;
        if (eventMonth != currentMonth) eventMonth = currentMonth;
        if (eventYear != currentYear) eventYear = currentYear;

        //Now the time and date can be reset according to the interval
        intervalTime = (int)hoursUntilNextRep;

        if (eventHour + intervalTime > 23) {

            eventHour = (eventHour + intervalTime) % 24;

            if (eventDay == monthNumberOfDays) {

                eventDay = 1;

                if (eventMonth == 11) {

                    eventMonth = 0;
                    eventYear++;
                }
                else eventMonth++;
            }
            else eventDay++;
        }
        else eventHour += intervalTime;

        return transformToMillis(eventMinute, eventHour, eventDay, eventMonth, eventYear);
    }

    public static long getNextAlternateRepetition(long currentDate, long eventStartDate, long eventStopDate, ArrayList<Integer> repetitionConfig, int intervalTime) {

        long repetition;

        int[] eventDateArray = transformFromMillis(eventStartDate);
        int[] currentDateArray = transformFromMillis(currentDate);

        int alternateInterval = repetitionConfig.get(0);

        //When the event start date is posterior to the current date, the next event's repetition will be its start date:
        if (isPosterior(eventStartDate, currentDate)) {
            repetition = eventStartDate;
        }

        //When the event start date is previous to the actual current one:
        else if (isPrevious(eventStartDate, currentDate)) {
            int numberOfDays = getNumberOfDays(eventStartDate, currentDate);

            int daysTillNextRep = (alternateInterval - (numberOfDays % alternateInterval)) % alternateInterval;

            if (daysTillNextRep == 0) {
                repetition = getNextDailyRepetition(currentDate, getIncreasedByDayDate(eventStartDate, numberOfDays), eventStopDate, intervalTime);
                if (isPosterior(repetition, currentDate)) repetition = getIncreasedByDayDate(eventStartDate, numberOfDays + alternateInterval);
            }
            else repetition = getIncreasedByDayDate(eventStartDate, numberOfDays + daysTillNextRep);
        }

        //When the current day is equal to the actual current one:
        else {
            repetition = eventStartDate;

            if (currentDateArray[HOUR] > eventDateArray[HOUR] || currentDateArray[HOUR] == eventDateArray[HOUR] && currentDateArray[MINUTE] > eventDateArray[MINUTE]) {

                int[] repetitionArray;

                //After that, the interval is going to be added to the repetition date until the repetition is bigger than the current day or the event stop date:
                while (repetition < currentDate && (repetition < eventStopDate || eventStopDate == -1)) {
                    repetitionArray = getIncrementedDate(repetition, intervalTime);
                    repetition = getMillisFromArray(repetitionArray);
                    if (isPosterior(repetition, currentDate)) repetition = getIncreasedByDayDate(eventStartDate, alternateInterval);
                }
            }
        }

        //In case of a repetition value bigger than the event stop date, the last repetition must be equal to the event start date, since that event is finished:
        if (repetition > eventStopDate && eventStopDate != -1) repetition = eventStartDate;

        return repetition;
    }

    public static long getNextWeeklyRepetition(long currentDate, long eventStartDate, long eventStopDate, ArrayList<Integer> repetitionConfig, int intervalTime) {

        long repetition;

        int[] eventDateArray = transformFromMillis(eventStartDate);
        int[] currentDateArray = transformFromMillis(currentDate);

        Integer currentDayOfWeek = getDayOfWeek(currentDateArray[DAY], currentDateArray[MONTH], currentDateArray[YEAR]);

        //When the event start date is posterior to the current date, the next event's repetition will be its start date:
        if (isPosterior(eventStartDate, currentDate)) {
            repetition = eventStartDate;
        }

        //When the event start date is previous to the actual current one:
        else if (isPrevious(eventStartDate, currentDate)) {

            repetition = currentDate;

            //First of all, the next day of week that is contained in the config array must be found, as well as the date that corresponds to that day:
            while (!repetitionConfig.contains(currentDayOfWeek)) {
                currentDayOfWeek = (currentDayOfWeek + 1) % 7;
                if (currentDayOfWeek == 0) currentDayOfWeek = 7;
                repetition = getIncreasedByDayDate(repetition, 1);
            }

            long nextFirstRepetition = getIncreasedByDayDate(eventStartDate, getNumberOfDays(eventStartDate, repetition));

            if (repetition == currentDate)
                repetition = getNextWeeklyRepetition(currentDate, nextFirstRepetition, eventStopDate, repetitionConfig, intervalTime);

            else repetition = nextFirstRepetition;
        }

        //When the current day is equal to the actual current one:
        else {
            repetition = eventStartDate;

            if (currentDateArray[HOUR] > eventDateArray[HOUR] || currentDateArray[HOUR] == eventDateArray[HOUR] && currentDateArray[MINUTE] > eventDateArray[MINUTE]) {

                int[] repetitionArray;

                //After that, the interval is going to be added to the repetition date until the repetition is bigger than the current day or the event stop date:
                while (repetition < currentDate && (repetition < eventStopDate || eventStopDate == -1)) {
                    repetitionArray = getIncrementedDate(repetition, intervalTime);
                    repetition = getMillisFromArray(repetitionArray);
                }

                if (isPosterior(repetition, currentDate)) {

                    repetition = eventStartDate;

                    do {
                        currentDayOfWeek = (currentDayOfWeek + 1) % 7;
                        if (currentDayOfWeek == 0) currentDayOfWeek = 7;
                        repetition = getIncreasedByDayDate(repetition, 1);
                    } while (!repetitionConfig.contains(currentDayOfWeek));
                }
            }
        }

        //In case of a repetition value bigger than the event stop date, the last repetition must be equal to the event start date, since that event is finished:
        if (repetition > eventStopDate && eventStopDate != -1) repetition = eventStartDate;

        return repetition;
    }

    public static long getNextMonthlyRepetition(long currentDate, long eventStartDate, long eventStopDate, ArrayList<Integer> repetitionConfig, int intervalTime) {

        long repetition;

        int[] eventDateArray = transformFromMillis(eventStartDate);
        int[] currentDateArray = transformFromMillis(currentDate);

        int currentYear = currentDateArray[YEAR];
        int currentMonth = currentDateArray[MONTH];
        Integer currentDayOfMonth = currentDateArray[DAY];

        //When the event start date is posterior to the current date, the next event's repetition will be its start date:
        if (isPosterior(eventStartDate, currentDate)) {
            repetition = eventStartDate;
        }

        //When the event start date is previous to the actual current one:
        else if (isPrevious(eventStartDate, currentDate)) {

            repetition = currentDate;

            //First of all, the next day of week that is contained in the config array must be found, as well as the date that corresponds to that day:
            while (!repetitionConfig.contains(currentDayOfMonth)) {
                currentDayOfMonth = currentDayOfMonth + 1;
                if (currentDayOfMonth > numberOfDays(currentMonth, currentYear)) {
                    currentDayOfMonth = 1;
                    int [] nextMonthAndYear = moveToNextMonth(currentMonth, currentYear);
                    currentMonth = nextMonthAndYear[0];
                    currentYear = nextMonthAndYear[1];
                }
                repetition = getIncreasedByDayDate(repetition, 1);
            }

            long nextFirstRepetition = getIncreasedByDayDate(eventStartDate, getNumberOfDays(eventStartDate, repetition));

            if (repetition == currentDate)
                repetition = getNextMonthlyRepetition(currentDate, nextFirstRepetition, eventStopDate, repetitionConfig, intervalTime);

            else repetition = nextFirstRepetition;
        }

        //When the current day is equal to the actual current one:
        else {
            repetition = eventStartDate;

            if (currentDateArray[HOUR] > eventDateArray[HOUR] || currentDateArray[HOUR] == eventDateArray[HOUR] && currentDateArray[MINUTE] > eventDateArray[MINUTE]) {

                int[] repetitionArray;

                //After that, the interval is going to be added to the repetition date until the repetition is bigger than the current day or the event stop date:
                while (repetition < currentDate && (repetition < eventStopDate || eventStopDate == -1)) {
                    repetitionArray = getIncrementedDate(repetition, intervalTime);
                    repetition = getMillisFromArray(repetitionArray);
                }

                if (isPosterior(repetition, currentDate)) {

                    repetition = eventStartDate;

                    do {
                        currentDayOfMonth = currentDayOfMonth + 1;
                        if (currentDayOfMonth > numberOfDays(currentMonth, currentYear)) {
                            currentDayOfMonth = 1;
                            int [] nextMonthAndYear = moveToNextMonth(currentMonth, currentYear);
                            currentMonth = nextMonthAndYear[0];
                            currentYear = nextMonthAndYear[1];
                        }
                        repetition = getIncreasedByDayDate(repetition, 1);
                    } while (!repetitionConfig.contains(currentDayOfMonth));
                }
            }
        }

        //In case of a repetition value bigger than the event stop date, the last repetition must be equal to the event start date, since that event is finished:
        if (repetition > eventStopDate && eventStopDate != -1) repetition = eventStartDate;

        return repetition;
    }

    public static long getNextAnnualRepetition(long currentDate, long eventStartDate, long eventStopDate, int intervalTime) {

        long repetition;

        int[] eventDateArray = transformFromMillis(eventStartDate);
        int[] currentDateArray = transformFromMillis(currentDate);

        //It is convenient to store ins simple variables the following values since they will be used more than once:
        int eventStartDay = eventDateArray[DAY];
        int eventStartMonth = eventDateArray[MONTH];
        int eventStartYear = eventDateArray[YEAR];

        int currentDay = currentDateArray[DAY];
        int currentMonth = currentDateArray[MONTH];
        int currentYear = currentDateArray[YEAR];

        //It is also important to know if the start day is the 29th and the start month is February:
        boolean startOnFeb29 = eventStartDay == 29 && eventStartMonth == 1;

        //When the event start date is posterior to the current date, the next event's repetition will be its start date:
        if (isPosterior(eventStartDate, currentDate)) {
            repetition = eventStartDate;
        }

        //When the event start date is previous or equal to the actual current one:
        else {

            //If the current month is bigger than the event's one, the next repetition will take place a year after the current one:
            if (currentMonth > eventStartMonth) {

                int nextYear = currentYear + 1;

                eventDateArray[YEAR] = nextYear;

                //When an event starts on the 29th of February, the start day must be checked for non leap years:
                if (startOnFeb29 && !leapYear(nextYear)) eventDateArray[DAY] = 28;

                repetition = getMillisFromArray(eventDateArray);
            }

            //If the current month is smaller than the event's one, the next repetition's year will be the current one:
            else if (currentMonth < eventStartMonth) {

                eventDateArray[YEAR] = currentYear;

                //When an event starts on the 29th of February, the start day must be checked for non leap years:
                if (startOnFeb29 && !leapYear(currentYear)) eventDateArray[DAY] = 28;

                repetition = getMillisFromArray(eventDateArray);
            }

            //If the current month is equals to te event start one, the next repetition must be calculated based on the year and the day:
            else {

                //If the current year and the event start year are different, it must be checked if the current year is leap or not and act consequently:
                if (eventStartYear < currentYear && startOnFeb29 && !leapYear(currentYear)) eventStartDay = eventDateArray[DAY] = 28;

                //If the event start day is bigger than the current day, the next repetition will be the start date in the current year:
                if (eventStartDay > currentDay) {
                    eventDateArray[YEAR] = currentYear;
                    repetition = getMillisFromArray(eventDateArray);
                }

                //If the event start day is smaller than the current one, the next repetition will take place in the next year:
                else if (eventStartDay < currentDay) {
                    int nextYear = currentYear + 1;

                    eventDateArray[YEAR] = nextYear;

                    //When an event starts on the 29th of February, the start day must be checked for non leap years:
                    if (startOnFeb29 && !leapYear(nextYear)) eventDateArray[DAY] = 28;

                    repetition = getMillisFromArray(eventDateArray);
                }

                //If the event start day is equals to the current one, the repetition could take place in different dates and times depending on the minutes and hours:
                else {

                    //First of all the repetition is set to the event start date but in the current year:
                    eventDateArray[YEAR] = currentYear;

                    repetition = getMillisFromArray(eventDateArray);

                    //Now the start time and the current time must be compared in order to determine if the repetition will take place in the current date or in the ext year:
                    if (currentDateArray[HOUR] > eventDateArray[HOUR] || currentDateArray[HOUR] == eventDateArray[HOUR] && currentDateArray[MINUTE] > eventDateArray[MINUTE]) {

                        int[] repetitionArray;

                        //After that, the interval is going to be added to the repetition date until the repetition is bigger than the current day or the event stop date:
                        while (repetition < currentDate && (repetition < eventStopDate || eventStopDate == -1)) {
                            repetitionArray = getIncrementedDate(repetition, intervalTime);
                            repetition = getMillisFromArray(repetitionArray);
                        }

                        //if repetition is posterior to the current date a recursive call to this method is make because that situation has been already contemplated:
                        if (isPosterior(repetition, currentDate))
                            repetition = getNextAnnualRepetition(repetition, eventStartDate, eventStopDate, intervalTime);
                    }
                }
            }
        }

        //In case of a repetition value bigger than the event stop date, the last repetition must be equal to the event start date, since that event is finished:
        if (repetition > eventStopDate && eventStopDate != -1) repetition = eventStartDate;

        return repetition;
    }

    //Method that returns whether or not the first date passed as parameter is completely previous to the second one (including time):
    public static boolean fullDateIsPrevious(String fullDate1, String fullDate2) {

        int HOUR, MINUTE, DAY, MONTH, YEAR;
        HOUR = DAY = 0;
        MINUTE = MONTH = 1;
        YEAR = 2;

        //The date and time are delimited by a space, so the regex \\s is used to split them:
        String[] dateAndTime1 = fullDate1.split("\\s");
        String[] dateAndTime2 = fullDate2.split("\\s");

        //Now each component of the date and the time strings are split as well:
        String[] date1 = dateAndTime1[0].split("/");
        String[] time1 = dateAndTime1[1].split(":");

        String[] date2 = dateAndTime2[0].split("/");
        String[] time2 = dateAndTime2[1].split(":");

        //Now the dates can be checked:
        return (
                Integer.parseInt(date1[YEAR]) < Integer.parseInt(date2[YEAR])

                        || Integer.parseInt(date1[YEAR]) == Integer.parseInt(date2[YEAR])
                        && Integer.parseInt(date1[MONTH]) < Integer.parseInt(date2[MONTH])

                        || Integer.parseInt(date1[YEAR]) == Integer.parseInt(date2[YEAR])
                        && Integer.parseInt(date1[MONTH]) == Integer.parseInt(date2[MONTH])
                        && Integer.parseInt(date1[DAY]) < Integer.parseInt(date2[DAY])

                        || Integer.parseInt(date1[YEAR]) == Integer.parseInt(date2[YEAR])
                        && Integer.parseInt(date1[MONTH]) == Integer.parseInt(date2[MONTH])
                        && Integer.parseInt(date1[DAY]) == Integer.parseInt(date2[DAY])
                        && Integer.parseInt(time1[HOUR]) < Integer.parseInt(time2[HOUR])

                        || Integer.parseInt(date1[YEAR]) == Integer.parseInt(date2[YEAR])
                        && Integer.parseInt(date1[MONTH]) == Integer.parseInt(date2[MONTH])
                        && Integer.parseInt(date1[DAY]) == Integer.parseInt(date2[DAY])
                        && Integer.parseInt(time1[HOUR]) == Integer.parseInt(time2[HOUR])
                        && Integer.parseInt(time1[MINUTE]) < Integer.parseInt(time2[MINUTE])
        );
    }

    //Method that returns the date that corresponds to incrementing the parameter date by numberOfHours:
    public static int[] getIncrementedDate (long date, int numberOfHours) {
        Calendar dateCalendar = Calendar.getInstance();
        dateCalendar.setTimeInMillis(date);

        int dateMinute = dateCalendar.get(Calendar.MINUTE);
        int dateHour = dateCalendar.get(Calendar.HOUR_OF_DAY);
        int dateDay = dateCalendar.get(Calendar.DAY_OF_MONTH);
        int dateMonth = dateCalendar.get(Calendar.MONTH);
        int dateYear = dateCalendar.get(Calendar.YEAR);

        if (numberOfHours >= 0) {
            if (dateHour + numberOfHours > 23) {

                dateHour = (dateHour + numberOfHours) % 24;

                if (dateDay == numberOfDays(dateMonth, dateYear)) {

                    dateDay = 1;

                    if (dateMonth == 11) {

                        dateMonth = 0;
                        dateYear++;
                    }
                    else dateMonth++;
                }
                else dateDay++;
            }
            else dateHour += numberOfHours;
        }

        return new int[] {dateMinute, dateHour, dateDay, dateMonth, dateYear};
    }

    //Method that returns the date that corresponds to decreasing the parameter date by numberOfMinutes:
    public static String getDecreasedByMinuteDate (int dateMinute, int dateHour, int dateDay, int dateMonth, int dateYear, int numberOfMinutes) {

        int numberOfHoursDecreased = 0;

        if (dateMinute - numberOfMinutes >= 0) dateMinute -= numberOfMinutes;

        else {
            dateMinute = 60 + (dateMinute - numberOfMinutes);
            numberOfHoursDecreased = 1;
        }

        return getDecreasedByHourDate(dateMinute, dateHour, dateDay, dateMonth, dateYear, numberOfHoursDecreased);
    }

    //Method that returns the date that corresponds to decreasing the parameter date by numberOfHours:
    public static String getDecreasedByHourDate (int dateMinute, int dateHour, int dateDay, int dateMonth, int dateYear, int numberOfHours) {

        int numberOfDaysDecreased = 0;

        if (dateHour - numberOfHours >= 0) dateHour -= numberOfHours;

        else {
            dateHour = 24 + (dateHour - numberOfHours);
            numberOfDaysDecreased = 1;
        }

        return getDecreasedByDayDate(dateMinute, dateHour, dateDay, dateMonth, dateYear, numberOfDaysDecreased);
    }

    //Method that decreases a date based on the specified number of days:
    public static String getDecreasedByDayDate(int dateMinute, int dateHour, int dateDay, int dateMonth, int dateYear, int numberOfDays) {

        for (; numberOfDays > 0; numberOfDays--) {
            if (dateDay > 1) dateDay--;
            else {
                if (dateMonth > 0) dateMonth--;
                else {
                    dateMonth = 11;
                    dateYear--;
                }
                dateDay = DateUtils.numberOfDays(dateMonth, dateYear);
            }
        }

        return formatDateText(dateDay, dateMonth, dateYear) + " " + formatTimeString(dateHour) + ":" + formatTimeString(dateMinute);
    }

    //Method that returns the date that corresponds to decreasing the parameter date by numberOfMonths:
    public static String getDecreasedByMonthDate (int dateMinute, int dateHour, int dateDay, int dateMonth, int dateYear, int numberOfMonths) {

        if (dateMonth - numberOfMonths >= 0) dateMonth -= numberOfMonths;

        else {
            dateMonth = 12 + (dateMonth - numberOfMonths);
            dateYear--;
        }

        int numberOfDays = numberOfDays(dateMonth, dateYear);

        if (dateDay > numberOfDays) dateDay = numberOfDays;

        return formatDateText(dateDay, dateMonth, dateYear) + " " + formatTimeString(dateHour) + ":" + formatTimeString(dateMinute);
    }

    //Method that decreases a date based on the specified number of days and returns a date in millis:
    public static long getDecreasedByDayDate(long dateInMillis, int numberOfDays) {

        int[] dateArray = transformFromMillis(dateInMillis);

        int dateMinute = dateArray[MINUTE];
        int dateHour = dateArray[HOUR];
        int dateDay = dateArray[DAY];
        int dateMonth = dateArray[MONTH];
        int dateYear = dateArray[YEAR];

        for (; numberOfDays > 0; numberOfDays--) {
            if (dateDay > 1) dateDay--;
            else {
                if (dateMonth > 0) dateMonth--;
                else {
                    dateMonth = 11;
                    dateYear--;
                }
                dateDay = DateUtils.numberOfDays(dateMonth, dateYear);
            }
        }

        return transformToMillis(dateMinute, dateHour, dateDay, dateMonth, dateYear);
    }

    //Method that decreases a date based on the specified number of days:
    public static long getIncreasedByDayDate(long dateInMillis, int numberOfDays) {

        int[] dateArray = transformFromMillis(dateInMillis);

        int dateMinute = dateArray[MINUTE];
        int dateHour = dateArray[HOUR];
        int dateDay = dateArray[DAY];
        int dateMonth = dateArray[MONTH];
        int dateYear = dateArray[YEAR];

        int monthNumberOfDays = DateUtils.numberOfDays(dateMonth, dateYear);

        for (; numberOfDays > 0; numberOfDays--) {
            if (dateDay < monthNumberOfDays) dateDay++;
            else {
                if (dateMonth < 11) dateMonth++;
                else {
                    dateMonth = 0;
                    dateYear++;
                }
                dateDay = 1;
                monthNumberOfDays = DateUtils.numberOfDays(dateMonth, dateYear);
            }
        }

        return transformToMillis(dateMinute, dateHour, dateDay, dateMonth, dateYear);
    }

    //This method generates a correctly formatted time string:
    public static String formatTimeString(int selectedTimeParameter) {
        if (selectedTimeParameter < 10) return "0" + selectedTimeParameter;
        else return "" + selectedTimeParameter;
    }

    //This method returns a complete date formatted text:
    public static String formatEventDateText(int eventDay, int eventMonth, int eventYear){
        String dateDivider = resources.getString(R.string.date_divider);

        String month = dateDivider + months[eventMonth];
        String year = dateDivider + eventYear;

        formattedDateText = eventDay + month + year;

        return daysOfWeekText[getDayOfWeek(eventDay, eventMonth, eventYear) - 1] + ", " + formattedDateText;
    }

    //This method returns a complete date formatted text:
    public static String formatCurrentDateText(String dayOfWeek, String dayNumber){
        String dateDivider = resources.getString(R.string.date_divider);

        String month = dateDivider + months[DateUtils.currentMonth];
        String year = dateDivider + DateUtils.currentYear;

        formattedDateText = dayNumber + month + year;

        return dayOfWeek + ", " + formattedDateText;
    }

    //This method returns a date formatted text:
    public static String formatDateText (int day, int month, int year){
        return DateUtils.formatTimeString(day) + "/" + DateUtils.formatTimeString(month + 1) + "/" + year;
    }

    //This method returns the number of days of the current month:
    public static int numberOfDays () {

        if (currentMonth == 1 && leapYear()) return 29;

        if (currentMonth == 1 && !leapYear()) return 28;

        if (currentMonth <= 6 && currentMonth % 2 == 0 || currentMonth > 6 && currentMonth % 2 != 0 )
            return 31;

        return 30;
    }

    //This method returns true if the current year is Leap Year:
    private static boolean leapYear() {

        if (currentYear % 4 == 0 && currentYear % 100 != 0)
            return true;

        if (currentYear % 400 == 0)
            return true;

        return false;
    }

    //This method returns the number of days of the given month:
    public static int numberOfDays (int month, int year) {

        if (month == 1 && leapYear(year)) return 29;

        if (month == 1 && !leapYear(year)) return 28;

        if (month <= 6 && month % 2 == 0 || month > 6 && month % 2 != 0 )
            return 31;

        return 30;
    }

    //This method returns true if the given year is Leap Year:
    private static boolean leapYear(int year) {

        if (year % 4 == 0 && year % 100 != 0)
            return true;

        if (year % 400 == 0)
            return true;

        return false;
    }

    //This method returns the starting week day for the current month:
    public static int findDayOfWeek() {
            double a = Math.floor((14 - (currentMonth + 1)) / 12);
            double y = currentYear - a;
            double m = (currentMonth + 1) + 12 * a - 2;
            double d = (1 + y + Math.floor(y / 4) - Math.floor(y / 100) + Math.floor(y / 400) + Math.floor((31 * m) / 12)) % 7;

            if (d == 0) return 7;
            else return (int) d;
    }

    //This method returns the starting week day for the given month inside the given year:
    public static int findDayOfWeek(int month, int year) {
        double a = Math.floor((14 - (month + 1)) / 12);
        double y = year - a;
        double m = (month + 1) + 12 * a - 2;
        double d = (1 + y + Math.floor(y / 4) - Math.floor(y / 100) + Math.floor(y / 400) + Math.floor((31 * m) / 12)) % 7;

        if (d == 0) return 7;
        else return (int) d;
    }

    //This method returns the day of week that corresponds to a specific day inside a month:
    public static int getDayOfWeek(int day, int month, int year) {
        int startingDayOfWeek = findDayOfWeek(month, year);

        //An array containing the first seven week days for the month is constructed (for example, if a month starts in friday, the array contents will be: {5,6,7,1,2,3,4}):
        int[] firstSevenDaysOfWeek = new int[7];

        for (int i = 0; i < 7; i++) {
            firstSevenDaysOfWeek[i] = (startingDayOfWeek + i) % 7;
            if (firstSevenDaysOfWeek[i] == 0) firstSevenDaysOfWeek[i] = 7;
        }

        //Now the calculation to get the week day for the current month day can be performed:
        int correspondingFirstSevenDays = day % 7;
        if (correspondingFirstSevenDays == 0) correspondingFirstSevenDays = 7;

        return firstSevenDaysOfWeek[correspondingFirstSevenDays - 1];
    }

    //This method transforms minutes into milliseconds:
    public static long minutesToMillis(long minutes) { return minutes * (60 * 1000); }

    //This method transforms the current date parameters into milliseconds:
    public static long getCurrentMillis() {
        return transformToMillis(0, 0, currentDay, currentMonth, currentYear);
    }

    //This method returns the millis of today's date:
    public static long getTodayMillis() {

        calendar = Calendar.getInstance();
        calendar.set(Calendar.MILLISECOND, 0);
        calendar.set(Calendar.SECOND, 0);

        return calendar.getTimeInMillis();
    }

    //This method returns a string with the current date formatted:
    public static String getTodayFormattedDate() {
        int[] todayArray = DateUtils.transformFromMillis(getTodayMillis());

        String dateText = DateUtils.formatDateText(todayArray[DAY], todayArray[MONTH], todayArray[YEAR]) + " " ;
        String timeText = DateUtils.formatTimeString(todayArray[HOUR]) + ":" + DateUtils.formatTimeString(todayArray[MINUTE]);

        return dateText + timeText;
    }

    //This method transforms a date array into millis:
    public static long getMillisFromArray(int[] dateArray) {
        return transformToMillis(dateArray[MINUTE], dateArray[HOUR], dateArray[DAY], dateArray[MONTH], dateArray[YEAR]);
    }

    //This method transforms the given parameters (that corresponds to a date) into milliseconds:
    public static long transformToMillis(int minute, int hour, int day, int month, int year) {
        Calendar calendar = Calendar.getInstance();

        calendar.set(Calendar.MILLISECOND, 0);
        calendar.set(Calendar.SECOND, 0);
        calendar.set(Calendar.MINUTE, minute);
        calendar.set(Calendar.HOUR_OF_DAY, hour);
        calendar.set(Calendar.DAY_OF_MONTH, day);
        calendar.set(Calendar.MONTH, month);
        calendar.set(Calendar.YEAR, year);

        return calendar.getTimeInMillis();
    }

    //This method transforms the given parameter (that corresponds to a date in millis) into minute, hour, day, month and year:
    public static int[] transformFromMillis(long timeInMillis) {
        Calendar calendar = Calendar.getInstance();
        calendar.setTimeInMillis(timeInMillis);

        return new int[] {
                calendar.get(Calendar.MINUTE),
                calendar.get(Calendar.HOUR_OF_DAY),
                calendar.get(Calendar.DAY_OF_MONTH),
                calendar.get(Calendar.MONTH),
                calendar.get(Calendar.YEAR)
        };
    }
}
